<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Drag by Controller (Quest) — With Z Movement (floor snap)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>

    <script>
    /* -----------------------------------------------------
        DRAG COMPONENT — MOVE OBJ BY RIGHT CONTROLLER
        + Z MOVEMENT BY LEFT CONTROLLER STICK
        (with floor constraint)
    ----------------------------------------------------- */
    AFRAME.registerComponent("arrastavel", {
        schema: { controllerId: { type: "string", default: "" } },

        init: function () {
            this.controllerEl = null;        // right controller (who grabbed)
            this.leftControllerEl = null;    // left controller (controls Z)

            // detect ground Y (assumes a single a-plane as ground)
            const ground = document.querySelector("a-plane");
            let gy = 0;
            if (ground) {
                const pos = ground.getAttribute("position");
                gy = (pos && typeof pos.y === "number") ? pos.y : (pos?.y ?? 0);
            }
            this.groundY = gy;
        },

        update: function () {
            this.controllerEl = this.data.controllerId
                ? document.querySelector("#" + this.data.controllerId)
                : null;

            this.leftControllerEl = document.querySelector("#leftHand");
        },

        tick: function () {
            if (!this.controllerEl) return;

            const rightCtrl = this.controllerEl;
            const leftCtrl = this.leftControllerEl;

            const obj = this.el.object3D;
            const ctrlObj = rightCtrl.object3D;

            if (!obj || !ctrlObj) return;

            // Forward vector (where controller is pointing)
            const forward = new THREE.Vector3(0, 0, -1)
                .applyQuaternion(ctrlObj.quaternion)
                .normalize();

            // Base: object stays 1.2m in front of controller
            const finalPos = ctrlObj.position.clone().add(
                forward.clone().multiplyScalar(1.2)
            );

            // FLOOR CONSTRAINT
            const bottomOffset = parseFloat(this.el.dataset.bottomOffset || "0");
            finalPos.y = Math.max(finalPos.y, this.groundY + bottomOffset);

            // Smooth follow position
            obj.position.lerp(finalPos, 0.4);

            /* --------------------------------------
                READ RIGHT CONTROLLER STICK (ROTATION)
            -------------------------------------- */
            let ax = 0; // left/right
            const tracked = rightCtrl.components["tracked-controls"];
            const gamepad = tracked?.controller?.gamepad;

            if (gamepad?.axes) {
                ax = gamepad.axes[2] ?? gamepad.axes[0] ?? 0;   // left/right
            }

            // Rotation increments (tune as needed)
            const rotSpeed = 0.05;

            // Apply rotation deltas
            obj.rotation.y -= ax * rotSpeed;  // rotate left/right
        }

    });

    /* -----------------------------------------------------
        QUEST PICK-UP SYSTEM (trigger / A button)
    ----------------------------------------------------- */
    AFRAME.registerComponent("quest-grab", {
        init: function () {
            this.isHolding = false;
            this.heldObject = null;

            this.onPress = this.onPress.bind(this);
            this.onRelease = this.onRelease.bind(this);

            this.el.addEventListener("triggerdown", this.onPress);
            this.el.addEventListener("triggerup", this.onRelease);
            this.el.addEventListener("abuttondown", this.onPress);
            this.el.addEventListener("abuttonup", this.onRelease);
        },

        onPress: function () {
            if (this.isHolding) return;

            const raycaster = this.el.components.raycaster;
            if (!raycaster || !raycaster.intersections.length) return;

            const target = raycaster.intersections[0].object.el;
            if (!target) return;

            if (target.classList.contains("ui-button")) {
                target.emit("click");
                return;
            }

            if (!target.classList.contains("clickable")) return;

            this.isHolding = true;
            this.heldObject = target;

            target.setAttribute("arrastavel", { controllerId: this.el.id });
        },

        onRelease: function () {
            if (!this.isHolding) return;

            this.isHolding = false;

            if (this.heldObject) {
                this.heldObject.removeAttribute("arrastavel");
                // Ensure on release the object is snapped to ground (in case it was slightly above)
                const bottomOffset = parseFloat(this.heldObject.dataset.bottomOffset || "0");
                const ground = document.querySelector("a-plane");
                let gy = 0;
                if (ground) {
                    const pos = ground.getAttribute("position");
                    gy = (pos && typeof pos.y === "number") ? pos.y : (pos?.y ?? 0);
                }
                const curPos = this.heldObject.getAttribute("position");
                const newY = Math.max(curPos.y, gy + bottomOffset);
                this.heldObject.setAttribute("position", { x: curPos.x, y: newY, z: curPos.z });

                this.heldObject = null;
            }
        }
    });

    /* -----------------------------------------------------
        SPAWNER BUTTON
        - calculates model bottom offset on model-loaded
        - initially snaps model to ground
    ----------------------------------------------------- */
    AFRAME.registerComponent("spawner", {
        schema: { model: { type: "string" } },
        init: function () {
            this.el.addEventListener("click", () => {
                const scene = document.querySelector("a-scene");

                const obj = document.createElement("a-entity");
                obj.setAttribute("gltf-model", this.data.model);
                // spawn slightly above so model-loaded can correctly compute bbox
                obj.setAttribute("position", "0 1 -2");
                obj.setAttribute("scale", "0.6 0.6 0.6");
                obj.classList.add("clickable", "spawned");

                // When the glTF finishes loading, compute bounding box and snap to floor
                obj.addEventListener("model-loaded", (ev) => {
                    try {
                        const threeObj = obj.object3D;

                        // garante que world matrices estejam atualizadas
                        threeObj.updateMatrixWorld(true);

                        // calcula bbox em world coords
                        const bbox = new THREE.Box3().setFromObject(threeObj);
                        const minY = bbox.min.y; // bottom in world coords

                        // pega a posição da origem da entidade em world coords
                        const worldOrigin = new THREE.Vector3();
                        threeObj.getWorldPosition(worldOrigin);
                        const originY = worldOrigin.y;

                        // bottomOffset = distância entre a origem da entidade (world) e a parte mais baixa da malha (world)
                        const bottomOffset = originY - minY;
                        obj.dataset.bottomOffset = bottomOffset.toString();

                        // detect ground Y
                        const ground = document.querySelector("a-plane");
                        let gy = 0;
                        if (ground) {
                            const pos = ground.getAttribute("position");
                            gy = (pos && typeof pos.y === "number") ? pos.y : (pos?.y ?? 0);
                        }

                        // snap the object so its bottom sits on ground
                        // aqui newY é a posição local desejada para que bottom fique em gy
                        const curPos = obj.getAttribute("position");
                        const newY = gy + bottomOffset;
                        obj.setAttribute("position", { x: curPos.x, y: newY, z: curPos.z });
                    } catch (err) {
                        console.warn("Erro ao calcular bbox do modelo:", err);
                    }
                });

                scene.appendChild(obj);
            });
        }
    });
    </script>
</head>

<body>
    <a-scene embedded vr-mode-ui="enabled: true" raycaster="objects: .clickable" cursor="rayOrigin: mouse">

    <a-assets>
        <!-- substitua o src abaixo pelo caminho correto do seu arquivo .glb -->
        <a-asset-item id="cadeira" src="chair.glb"></a-asset-item>
    </a-assets>

    <!-- RIGHT HAND -->
    <a-entity id="rightHand"
                laser-controls="hand: right"
                raycaster="objects: .clickable"
                quest-grab></a-entity>

    <!-- LEFT HAND (used for Z movement) -->
    <a-entity id="leftHand"
                laser-controls="hand: left"></a-entity>

    <!-- ENVIRONMENT -->
    <!-- Ground plane placed at y=0 by default -->
    <a-plane id="ground" width="20" height="20" rotation="-90 0 0" color="#6BC48C" position="0 0 0"></a-plane>
    <a-sky color="#D0D0D0"></a-sky>

    <!-- CAMERA + HUD -->
    <a-entity camera position="0 1.6 2">
        <a-entity id="hud"
                position="0 -0.7 -1.5"
                geometry="primitive: plane; width: 2; height: 0.6"
                material="color: black; opacity: 0.35">

            <!-- botão de spawn: usa o mesmo gltf-model do asset, posicionado no HUD -->
            <a-entity id="spawn-btn"
                        gltf-model="#cadeira"
                        class="clickable ui-button"
                        scale="0.18 0.18 0.18"
                        position="-0.5 -0.15 0"
                        spawner="model: #cadeira">
            </a-entity>

        </a-entity>
    </a-entity>

    </a-scene>
</body>
</html>
